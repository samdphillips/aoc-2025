#lang rhombus/static

import:
  rhombus/measure
  "util/advent_of_code.rhm" as aoc
  "util/grid.rhm" open
  "util/misc.rhm" open

@example_input(test_input1)|<{
..@@.@@@@.
@@@.@.@.@@
@@@@@.@.@@
@.@@@@..@.
@@.@@@@.@@
.@@@@@@@.@
.@.@.@.@@@
@.@@@.@@@@
.@@@@@@@@.
@.@.@@@.@.
}>|

fun get_puzzle_input():
  aoc.fetch_input(aoc.find_session(), 2025, 4)

fun parse_input(input :: String, make) :: Grid:
  make(input)

fun find_reachable(g :: Grid) :~ Set.of(Posn):
  // use_dynamic otherwise uses Grid methods for subclasses
  // dg is g without any static information
  use_dynamic
  let dg = dynamic(g)
  for Set:
    each y: g.rows
    each x: g.cols
    def p = Posn(x, y)
    keep_when: dg[p] == Char"@"
    def num_neigh:
      for math.sum (n: p.neighbors8()):
        keep_when: g.in_grid(n)
        keep_when: dg[n] == Char"@"
        1
    keep_when: num_neigh < 4
    p

fun run1(s):
  def g = parse_input(s, Grid)
  find_reachable(g).length()

module test:
  check run1(test_input1) ~is 13

module part1:
  def input = get_puzzle_input()
  measure.time:
    run1(input)

class RGrid(removed :: Set.of(Posn)):
  extends Grid

  constructor
  | (s :: String):
      super(s)(Set{})
  | (lines, width, height, removed):
      super(lines, width, height)(removed)

  reconstructor (lines, w, h, r):
    RGrid(lines, w, h, r)

  method remove_all(ps :: Set) :: RGrid:
    this with (removed = removed ++ ps)

  override method get(p :~ Posn):
    if removed.contains(p)
    | Char"."
    | super.get(p)

fun clear_once(g :: RGrid) :: maybe(RGrid):
  match find_reachable(g)
  | Set.empty: #false
  | ps: g.remove_all(ps)

fun run2(s):
  recur remove_rolls(g :~ RGrid = parse_input(s, RGrid)):
    match clear_once(g)
    | g :: RGrid: remove_rolls(g)
    | ~else: g.removed.length()

module test:
  check run2(test_input1) ~is 43

module part2:
  def input = get_puzzle_input()
  measure.time:
    run2(input)
