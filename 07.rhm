#lang rhombus/static

import:
  rhombus/measure
  "util/advent_of_code.rhm" as aoc
  "util/grid.rhm" open
  "util/misc.rhm" open

@example_input(test_input1){
.......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............
}

fun get_puzzle_input():
  aoc.fetch_input(aoc.find_session(), 2025, 7)

fun step1(g :~ Grid, p :~ Posn, count_splits :~ Nat)
  :~ values(Set.of(Posn), Nat):
  let p = p <+> Posn.S
  match g[p]
  | Char"^": values({ p <+> Posn.W, p <+> Posn.E }, count_splits + 1)
  | ~else: values({ p }, count_splits)

fun step(g :: Grid, ps0 :: Set.of(Posn), count_splits :: Nat)
  :~ values(Set.of(Posn), Nat):
  for values(ps1 :~ Set = Set{}, count_splits = count_splits) (p: ps0):
    let values(ps2, count_splits) = step1(g, p, count_splits)
    values(ps1 ++ ps2, count_splits)

fun run1(s):
  def g :~ Grid = Grid(s)
  def init = g.find_char(Char"S")
  def values(ps, count_splits):
    for values(ps = {init}, c = 0) (i: g.rows):
      step(g, ps, c)
  count_splits

module test:
  check run1(test_input1) ~is 21

module part1:
  def input = get_puzzle_input()
  measure.time:
    run1(input)

fun run2(s):
  def g :~ Grid = Grid(s)
  def init = g.find_char(Char"S")
  recur do_splits(i :~ Nat = g.height + 1, ps :~ Map.of(Posn, Nat) = {init: 1}):
    cond
    | i == 0: math.sum(&ps.values())
    | ~else:
        def nps:
          for values(nps :~ Map.of(Posn, Nat) = {}) (values(p, n): ps):
            fun get_count(p :~ Posn): nps.get(p, 0) + n
            let p = p <+> Posn.S
            let ps:
              match g[p]
              | Char"^": let l = p <+> Posn.W
                         let r = p <+> Posn.E
                         {l: get_count(l), r: get_count(r)}
              | ~else: {p: get_count(p)}
            nps ++ ps
        do_splits(i - 1, nps)

module test:
  check run2(test_input1) ~is 40


module part2:
  def input = get_puzzle_input()
  measure.time:
    run2(input)
