#lang rhombus/static

import:
  rhombus/measure
  "util/advent_of_code.rhm" as aoc
  "util/grid.rhm" open
  "util/misc.rhm" open

@example_input(test_input1){
.......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............
}

fun get_puzzle_input():
  aoc.fetch_input(aoc.find_session(), 2025, 7)

fun step1(g :~ Grid, p :~ Posn, count_splits :~ Nat)
  :~ values(Set.of(Posn), Nat):
  let p = p <+> Posn.S
  match g[p]
  | Char"^": values({ p <+> Posn.W, p <+> Posn.E }, count_splits + 1)
  | ~else: values({ p }, count_splits)

fun step(g :: Grid, ps0 :: Set.of(Posn), count_splits :: Nat)
  :~ values(Set.of(Posn), Nat):
  for values(ps1 :~ Set = Set{}, count_splits = count_splits) (p: ps0):
    let values(ps2, count_splits) = step1(g, p, count_splits)
    values(ps1 ++ ps2, count_splits)

fun run1(s):
  def g :~ Grid = Grid(s)
  def init = g.find_char(Char"S")
  def values(ps, count_splits):
    for values(ps = {init}, c = 0) (i: g.rows):
      step(g, ps, c)
  count_splits

module test:
  check run1(test_input1) ~is 21

module part1:
  def input = get_puzzle_input()
  measure.time:
    run1(input)

fun run2(s): #void

#//
module test:
  check run2(test_input1) ~is #false


module part2:
  def input = get_puzzle_input()
  measure.time:
    run2(input)
