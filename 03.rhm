#lang rhombus/static

import:
  rhombus/measure
  "util/advent_of_code.rhm" as aoc
  "util/misc.rhm" open

@example_input(test_input1){
987654321111111
811111111111119
234234234234278
818181911112111
}

fun get_puzzle_input():
  aoc.fetch_input(aoc.find_session(), 2025, 3)

fun parse_input(input :: String) :: List.of(Bytes):
  input.split("\n").map(String.latin1_bytes)

fun byte_to_num(b :: Byte) :: Nat:
  b - #"0"[0]

fun find_best_index(s :: Bytes,
                    ~start: start :: Nat = 0,
                    ~end: end :: Nat = 0) :: values(Byte, Nat):
  // end is the offset relative to the end of the string
  def real_end = s.length() - end
  for values(best = #false, j = #false) (i: start..real_end):
    if !best || s[i] > best
    | values(s[i], i)
    | values(best, j)

// Original for part one
#//
fun bank_jolts(bs :: Bytes) :: Nat:
  def values(a, i) = find_best_index(bs, ~end: 1)
  def values(b, _) = find_best_index(bs, ~start: i + 1)
  byte_to_num(a) * 10 + byte_to_num(b)

fun bank_jolts(bs :: Bytes, n :: Nat):
  // println(bs)
  recur rest(i = 0, j = n - 1, result = 0):
    // println(@str{@i @j @result})
    if j < 0
    | result
    | def values(v, k) = find_best_index(bs, ~start: i, ~end: j)
      rest(k + 1, j - 1, result * 10 + byte_to_num(v))

module test:
  block:
    def input = parse_input(test_input1)
    check input.map(bank_jolts(_, 2)) ~is [98, 89, 78, 92]
    check input.map(bank_jolts(_, 12)) ~is:
      [987654321111, 811111111119, 434234234278, 888911112111]

fun run1(s):
  def input = parse_input(s)
  for math.sum (b: input):
    bank_jolts(b, 2)

module test:
  check run1(test_input1) ~is 357

module part1:
  def input = get_puzzle_input()
  measure.time:
    run1(input)

fun run2(s):
  def input = parse_input(s)
  for math.sum (b: input):
    bank_jolts(b, 12)

module test:
  check run2(test_input1) ~is 3121910778619

module part2:
  def input = get_puzzle_input()
  measure.time:
    run2(input)
